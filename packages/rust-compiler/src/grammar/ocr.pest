/* PROGRAM MATCHING */
program = _{SOI ~ lines ~ EOI}

/* 
 * A line list can have any number of line breaks at the start and end and any number of lines in between.
 * However the last line in a line list may be a statement (because there might not be a line break after it).
 * So for the majority of the statement, the OR expression will match `line` but if the parser is on the final line and it doesn't have a line break after it, it will match it as a statement
 * However both line and statement are silent so this logic will not appear in the parse tree
 */
lines = _{
	NEWLINE* ~ (line | statement)* ~ NEWLINE* 
}

line = _{
	statement ~ NEWLINE+
}

statement = _{ comment | assignment | expression }

/* STATEMENT TYPES */

// Comment
commentDelimeter = _{ "//"}
comment = { commentDelimeter ~ (!(NEWLINE) ~ ANY)* }

// Assignments & Declarations
declarationKeyword = _{ constKeyword | globalKeyword }
assignment = _{
	arrayDeclaration | arrayAssignment | taggedVariableAssignment | variableAssignment
}

variableAssignment = !{
	identifier ~ assignmentOperator ~ expression
}

taggedVariableAssignment = ${
	declarationKeyword ~ WHITESPACE+ ~ variableAssignment
}

// Array Declarations
arrayValue = _{ arrayValues | expression }
arrayValues = !{ "[" ~ (arrayValue ~ ",")* ~ arrayValue ~ "]" }
arrayEmptyValues = { "[" ~ "]" }
array = { arrayValues | arrayEmptyValues }
arrayIndexing = { identifier ~ arrayValues }
arraySetting = ${
	WHITESPACE* ~ assignmentOperator ~ WHITESPACE*
}
arrayDeclaration = ${
	arrayKeyword ~ WHITESPACE+ ~ arrayIndexing ~ (arraySetting ~ array)?
}
arrayAssignment = ${ 
	arrayIndexing ~ arraySetting ~ expression
}

// Function calls
functionCall = ${
	identifier ~ functionParameters
}
functionParameters = {
	"(" ~ ((expression ~ "," ~ WHITESPACE*)* ~ expression)? ~ ")"
}

/* EXPRESSIONS */
expression = _{
	"(" ~ expressionTypes ~ ")" | expressionTypes
}
expressionTypes = _{
	arrayIndexing | array | functionCall | identifier | literal
}

/* DATA TYPES */
literal = {
	(
	number | 
	string
	) ~ !identifierCharacters
}
number = @{
	("+" | "-")? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT*)?
}
string = {
	"d"
}

/* IDENTIFIERS */ 
identifierCharacters = _{ ASCII_ALPHANUMERIC | "_" }
identifier = @{ !keyword ~ (ASCII_ALPHA | "_") ~ identifierCharacters* }

/* KEYWORDS */
keyword = @{
	(
	constKeyword | 
	globalKeyword | 
	arrayKeyword
	) ~ !identifierCharacters
}
constKeyword = { "const" }
globalKeyword = { "global" }
arrayKeyword = { "array"}

/* OPERATORS */
assignmentOperator = _{ "=" }

/* MISC */
WHITESPACE = _{ " " | "\t" }
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }